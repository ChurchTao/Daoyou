# 排名机制

<cite>
**本文档引用的文件**   
- [rankings.ts](file://lib/redis/rankings.ts)
- [route.ts](file://app/api/rankings/route.ts)
- [my-rank/route.ts](file://app/api/rankings/my-rank/route.ts)
- [RankingListItem.tsx](file://components/RankingListItem.tsx)
- [index.ts](file://lib/redis/index.ts)
- [rank-rewards/route.ts](file://app/api/cron/rank-rewards/route.ts)
- [rankingUtils.ts](file://utils/rankingUtils.ts)
- [constants.ts](file://types/constants.ts)
</cite>

## 目录
1. [简介](#简介)
2. [核心数据结构与算法](#核心数据结构与算法)
3. [Redis Sorted Set 排名实现](#redis-sorted-set-排名实现)
4. [核心操作与原子性保障](#核心操作与原子性保障)
5. [定时任务与数据同步](#定时任务与数据同步)
6. [API 接口设计](#api-接口设计)
7. [前端组件与用户交互](#前端组件与用户交互)
8. [性能优化与内存管理](#性能优化与内存管理)
9. [总结](#总结)

## 简介
本系统实现了基于 Redis Sorted Set 的高效、实时排行榜排名机制，支持万界金榜的实时更新、挑战、查询等功能。系统通过 Redis 的有序集合（Sorted Set）数据结构，以排名作为分值（score），角色 ID 作为成员（member），实现了 O(log N) 复杂度的插入、删除和范围查询操作。排行榜支持 TOP 100 自动截断、新上榜保护、每日挑战次数限制等特性，并通过 Vercel Cron 定时任务实现每日奖励结算。

## 核心数据结构与算法
系统定义了清晰的排名数据结构和算法，确保数据的一致性和可扩展性。

### 排名项数据结构
```typescript
export interface RankingItem extends CultivatorBasic {
  rank: number;
  faction?: string;
  is_new_comer: boolean; // 是否为新天骄（2小时内）
  updated_at: number;
}
```

### 排名信息查询结构
```typescript
export interface CultivatorRankInfo {
  rank: number | null; // null表示不在榜上
  isProtected: boolean;
  remainingChallenges: number;
}
```

### 排行榜常量配置
```typescript
const MAX_RANKING_SIZE = 100; // 排行榜最大容量
const PROTECTION_DURATION = 1800; // 保护期时长（秒）
const LOCK_DURATION = 300; // 挑战锁时长（秒）
const MAX_DAILY_CHALLENGES = 10; // 每日最大挑战次数
```

**Section sources**
- [rankings.ts](file://lib/redis/rankings.ts#L14-L17)

## Redis Sorted Set 排名实现
系统利用 Redis Sorted Set 的有序特性实现高效的排名计算与范围查询。

### 数据结构设计
系统采用 Redis Sorted Set 存储排行榜数据，其中：
- **Key**: `golden_rank:list` - 存储所有上榜角色的有序集合
- **Score**: 使用排名作为分值（1-based），确保排名越靠前分值越小
- **Member**: 角色 ID（cultivatorId），作为集合中的成员

### 辅助数据结构
系统使用多个 Redis Key 前缀管理辅助信息：
- `golden_rank:protection:` - 新上榜保护状态
- `golden_rank:daily_challenges:` - 每日挑战次数计数
- `golden_rank:challenge_lock:` - 挑战锁状态

```mermaid
erDiagram
RANKING_LIST {
string key PK
number score
string member
}
PROTECTION {
string key PK
string value
number ttl
}
DAILY_CHALLENGES {
string key PK
number value
number ttl
}
CHALLENGE_LOCK {
string key PK
string value
number ttl
}
RANKING_LIST ||--o{ PROTECTION : "has"
RANKING_LIST ||--o{ DAILY_CHALLENGES : "has"
RANKING_LIST ||--o{ CHALLENGE_LOCK : "has"
```

**Diagram sources **
- [rankings.ts](file://lib/redis/rankings.ts#L8-L12)

## 核心操作与原子性保障
系统通过精心设计的算法和 Redis Pipeline 机制确保核心操作的原子性和一致性。

### 排名更新流程
```mermaid
sequenceDiagram
participant 挑战者
participant 排行榜系统
participant Redis
挑战者->>排行榜系统 : 发起挑战请求
排行榜系统->>Redis : 获取被挑战者排名
Redis-->>排行榜系统 : 返回排名
排行榜系统->>Redis : 获取挑战者排名
Redis-->>排行榜系统 : 返回排名
排行榜系统->>Redis : 创建Pipeline
Redis-->>排行榜系统 : 返回Pipeline
排行榜系统->>Redis : 执行排名调整命令
排行榜系统->>Redis : 执行挑战者排名更新
排行榜系统->>Redis : 执行被挑战者及后续排名下移
排行榜系统->>Redis : 执行Pipeline
Redis-->>排行榜系统 : 返回执行结果
排行榜系统->>挑战者 : 返回挑战结果
```

**Diagram sources **
- [rankings.ts](file://lib/redis/rankings.ts#L190-L270)

### 排名更新原子性保障
`updateRanking` 函数通过 Redis Pipeline 确保所有操作的原子性：

```mermaid
flowchart TD
Start([开始更新排名]) --> CheckTargetRank["检查被挑战者排名"]
CheckTargetRank --> TargetExists{"被挑战者在榜上?"}
TargetExists --> |否| Error["抛出异常"]
TargetExists --> |是| CheckChallengerRank["检查挑战者排名"]
CheckChallengerRank --> ChallengerExists{"挑战者在榜上?"}
ChallengerExists --> |否| InsertNewChallenger["新挑战者插入"]
ChallengerExists --> |是| ValidateRank["验证排名规则"]
ValidateRank --> Valid{"挑战者排名更高?"}
Valid --> |否| Error
Valid --> |是| AdjustRanks["调整后续排名"]
InsertNewChallenger --> UpdateChallengerRank["更新挑战者排名"]
AdjustRanks --> UpdateChallengerRank
UpdateChallengerRank --> UpdateOthersRank["更新其他角色排名"]
UpdateOthersRank --> TruncateRanking["截断排行榜"]
TruncateRanking --> End([排名更新完成])
```

**Diagram sources **
- [rankings.ts](file://lib/redis/rankings.ts#L190-L270)

### 排名插入与调整
当需要在特定位置插入排名时，系统先调整后续排名，再插入新成员：

```mermaid
flowchart TD
Start([开始插入排名]) --> GetMembers["获取目标排名及之后成员"]
GetMembers --> MembersExist{"有成员需要调整?"}
MembersExist --> |否| End
MembersExist --> |是| CreatePipeline["创建Pipeline"]
CreatePipeline --> LoopStart["开始循环"]
LoopStart --> GetMember["获取成员"]
GetMember --> CalculateNewRank["计算新排名"]
CalculateNewRank --> AddToPipeline["添加zadd命令到Pipeline"]
AddToPipeline --> LoopEnd{"循环结束?"}
LoopEnd --> |否| LoopStart
LoopEnd --> |是| ExecutePipeline["执行Pipeline"]
ExecutePipeline --> Truncate["截断排行榜"]
Truncate --> End([插入完成])
```

**Diagram sources **
- [rankings.ts](file://lib/redis/rankings.ts#L162-L185)

**Section sources**
- [rankings.ts](file://lib/redis/rankings.ts#L162-L185)

## 定时任务与数据同步
系统通过定时任务实现排行榜数据的同步和奖励结算。

### 定时任务配置
Vercel Cron 配置文件定义了定时任务的执行计划：

```json
{
  "crons": [
    {
      "path": "/api/market",
      "schedule": "0 1 * * *"
    },
    {
      "path": "/api/cron/rank-rewards",
      "schedule": "0 0 * * *"
    }
  ]
}
```

### 每日奖励结算流程
```mermaid
sequenceDiagram
participant Cron
participant 排行榜奖励服务
participant 数据库
Cron->>排行榜奖励服务 : 触发每日奖励结算
排行榜奖励服务->>数据库 : 查询前100名角色
数据库-->>排行榜奖励服务 : 返回角色ID列表
排行榜奖励服务->>排行榜奖励服务 : 遍历角色列表
loop 每个角色
排行榜奖励服务->>排行榜奖励服务 : 计算奖励数量
排行榜奖励服务->>数据库 : 更新灵石数量
数据库-->>排行榜奖励服务 : 返回更新结果
end
排行榜奖励服务->>Cron : 返回结算结果
```

**Diagram sources **
- [vercel.json](file://vercel.json#L3-L12)
- [rank-rewards/route.ts](file://app/api/cron/rank-rewards/route.ts#L7-L67)

### 奖励规则配置
```typescript
export const RANKING_REWARDS = {
  1: 30000,
  2: 20000,
  3: 15000,
  '4-10': 8000,
  '11-50': 5000,
  '51-100': 2000,
  default: 1000,
};
```

**Section sources**
- [rank-rewards/route.ts](file://app/api/cron/rank-rewards/route.ts#L3-L46)
- [constants.ts](file://types/constants.ts#L182-L189)

## API 接口设计
系统提供了清晰的 API 接口供前端调用。

### 主榜单查询接口
```mermaid
sequenceDiagram
participant 前端
participant 排行榜API
participant Redis
前端->>排行榜API : GET /api/rankings
排行榜API->>Redis : 获取排行榜顺序
Redis-->>排行榜API : 返回成员列表
排行榜API->>Redis : 获取保护状态
Redis-->>排行榜API : 返回保护状态
排行榜API->>数据库 : 批量查询角色基本信息
数据库-->>排行榜API : 返回角色信息
排行榜API->>排行榜API : 组合排名信息
排行榜API-->>前端 : 返回排行榜数据
```

**Diagram sources **
- [route.ts](file://app/api/rankings/route.ts#L9-L30)
- [rankings.ts](file://lib/redis/rankings.ts#L76-L108)

### 个人排名查询接口
```mermaid
sequenceDiagram
participant 前端
participant 个人排名API
participant Redis
participant Supabase
前端->>个人排名API : GET /api/rankings/my-rank
个人排名API->>Supabase : 验证用户身份
Supabase-->>个人排名API : 返回用户信息
个人排名API->>Redis : 获取角色排名
Redis-->>个人排名API : 返回排名
个人排名API->>Redis : 获取剩余挑战次数
Redis-->>个人排名API : 返回挑战次数
个人排名API->>Redis : 检查保护状态
Redis-->>个人排名API : 返回保护状态
个人排名API-->>前端 : 返回个人排名信息
```

**Diagram sources **
- [my-rank/route.ts](file://app/api/rankings/my-rank/route.ts#L13-L62)

**Section sources**
- [route.ts](file://app/api/rankings/route.ts#L9-L30)
- [my-rank/route.ts](file://app/api/rankings/my-rank/route.ts#L13-L62)

## 前端组件与用户交互
前端组件实现了榜单数据的渲染和用户交互功能。

### 排行榜列表项组件
```mermaid
classDiagram
class RankingListItem {
+item : RankingsDisplayItem
+isSelf : boolean
+canChallenge : boolean
+isChallenging : boolean
+isProbing : boolean
+onChallenge(targetId : string) : Promise~void~
+onProbe(targetId : string) : Promise~void~
+customSubtitle? : string
+customMeta? : string
+isItem? : boolean
}
class RankingsDisplayItem {
<<union>>
}
class BattleRankingItem {
+rank : number
+name : string
+title : string
+realm : string
+realm_stage : string
+age : number
+origin : string
+is_new_comer : boolean
}
class ItemRankingEntry {
+rank : number
+name : string
+type? : string
+quality? : string
+grade? : string
+ownerName : string
+score : number
+description? : string
}
RankingsDisplayItem <|-- BattleRankingItem
RankingsDisplayItem <|-- ItemRankingEntry
RankingListItem --> RankingsDisplayItem : "使用"
```

**Diagram sources **
- [RankingListItem.tsx](file://components/RankingListItem.tsx#L23-L34)
- [rankings.ts](file://types/rankings.ts#L1-L21)

### 组件渲染逻辑
```mermaid
flowchart TD
Start([组件渲染]) --> CheckItemType["检查是否为物品榜"]
CheckItemType --> |否| RenderBattleItem["渲染战斗角色信息"]
CheckItemType --> |是| RenderItem["渲染物品信息"]
RenderBattleItem --> RenderRank["渲染排名"]
RenderBattleItem --> RenderName["渲染姓名和标题"]
RenderBattleItem --> RenderRealm["渲染境界信息"]
RenderBattleItem --> RenderOrigin["渲染来源信息"]
RenderBattleItem --> RenderButtons["渲染操作按钮"]
RenderItem --> RenderRank
RenderItem --> RenderName
RenderItem --> RenderQuality["渲染品质信息"]
RenderItem --> RenderOwner["渲染拥有者"]
RenderItem --> RenderDescription["渲染描述"]
RenderRank --> End
RenderName --> End
RenderRealm --> End
RenderOrigin --> End
RenderButtons --> End
RenderQuality --> End
RenderOwner --> End
RenderDescription --> End
```

**Section sources**
- [RankingListItem.tsx](file://components/RankingListItem.tsx#L47-L117)

## 性能优化与内存管理
系统通过多种策略优化性能和内存使用。

### 内存使用估算
假设每个角色基本信息约 200 字节，100 个角色约 20KB，加上 Redis 数据结构开销，总内存使用约 50KB。

### 缓存失效策略
系统采用以下缓存失效策略：
- **TTL 过期**: 每日挑战次数计数在午夜自动过期
- **主动清理**: 移除角色时清理相关缓存数据
- **大小限制**: 排行榜自动截断至 TOP 100

### 并发读写优化
- **读操作**: 使用 Redis 的高效范围查询，支持高并发读取
- **写操作**: 通过 Pipeline 减少网络往返，提高写入效率
- **锁机制**: 使用分布式锁防止并发挑战冲突

**Section sources**
- [rankings.ts](file://lib/redis/rankings.ts#L400-L408)

## 总结
本排名机制通过 Redis Sorted Set 实现了高效、实时的排名计算与查询，支持复杂的排名更新逻辑和丰富的业务功能。系统通过 Pipeline 保证操作原子性，通过定时任务实现数据同步，通过合理的数据结构设计确保性能和可扩展性。前端组件与 API 接口设计清晰，为用户提供流畅的交互体验。