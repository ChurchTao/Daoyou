# 副本机制

<cite>
**本文档引用文件**   
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L1-L850)
- [ResourceEngine.ts](file://engine/resource/ResourceEngine.ts#L1-L445)
- [types.ts](file://lib/dungeon/types.ts#L1-L195)
- [types.ts](file://engine/resource/types.ts#L1-L74)
- [prompts.ts](file://utils/prompts.ts#L1-L385)
- [dungeonLimiter.ts](file://lib/dungeon/dungeonLimiter.ts#L1-L56)
- [route.ts](file://app/api/dungeon/history/route.ts#L1-L65)
- [page.tsx](file://app/(main)/game/dungeon/history/page.tsx#L1-L286)
- [route.ts](file://app/api/dungeon/limit/route.ts#L1-L24)
</cite>

## 更新摘要
**变更内容**   
- 新增了基于玩家与副本境界差异的动态叙事难度调整机制，通过`calculateRealmGap`和`getRealmGuidance`方法实现。
- 将资源消耗与获得的逻辑从`DungeonService`迁移至新的`ResourceEngine`服务，实现事务性处理。
- 更新了五轮制副本相位的定义，使其在境界碾压场景下呈现不同的叙事逻辑。
- 重构了`handleAction`和`settleDungeon`方法，以集成`ResourceEngine`。
- 新增副本历史功能，允许玩家查看过往副本记录，相关实现位于`app/api/dungeon/history/route.ts`和`app/(main)/game/dungeon/history/page.tsx`。
- 新增副本限制器功能，通过`lib/dungeon/dungeonLimiter.ts`和`app/api/dungeon/limit/route.ts`控制玩家每日参与副本的次数。

## 目录
1. [引言](#引言)
2. [核心状态机设计](#核心状态机设计)
3. [五轮制副本相位与AI叙事逻辑](#五轮制副本相位与ai叙事逻辑)
4. [危险分与资源消耗机制](#危险分与资源消耗机制)
5. [战斗拦截与集成机制](#战斗拦截与集成机制)
6. [状态流转与交互序列](#状态流转与交互序列)
7. [异常情况恢复策略](#异常情况恢复策略)
8. [副本限制器](#副本限制器)
9. [副本历史](#副本历史)
10. [结论](#结论)

## 引言

《万界道友》中的副本系统是一个由AI驱动的、高自由度的文字修仙体验核心。该系统以`DungeonService`类为核心，通过精心设计的状态机与AI交互机制，为玩家提供符合“凡人流”风格的动态叙事与抉择体验。本文档将深入解析其从初始化到结算的完整生命周期，重点阐述其状态流转、AI引导、战斗集成与资源管理等关键设计。

**Section sources**
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L1-L850)
- [README.md](file://README.md#L1-L282)

## 核心状态机设计

副本系统的核心是一个基于Redis的持久化状态机，其生命周期由`DungeonService`类管理。整个流程始于`startDungeon`，经由`handleAction`处理玩家选择，最终通过`handleBattleCallback`或`settleDungeon`完成。

### 状态定义与初始化

`DungeonState`接口定义了副本的完整状态，包括玩家信息、当前轮次、历史记录、危险分、资源消耗摘要等。当玩家调用`startDungeon`时，系统会执行以下步骤：
1.  **会话检查**：通过`getDungeonKey`生成基于`cultivatorId`的Redis键，检查是否存在进行中的副本。
2.  **上下文准备**：调用`prepareDungeonContext`获取玩家数据和地图节点信息。
3.  **状态初始化**：创建初始`DungeonState`对象，设置`currentRound`为1，`maxRounds`为5，并初始化`dangerScore`为10。
4.  **AI首次调用**：通过`callAI`方法，将初始状态发送给AI，生成第一轮的场景描述和选项。
5.  **状态持久化**：将包含AI生成结果的完整状态通过`saveState`方法存入Redis，设置1小时的过期时间。

此设计确保了副本状态的可恢复性，即使玩家断开连接，也能通过`getState`方法从Redis中恢复进度。

### 状态流转与处理

`handleAction`是状态流转的核心。当玩家做出选择后，该方法会：
1.  **获取当前状态**：从Redis中读取`DungeonState`。
2.  **处理消耗**：利用`ResourceEngine`校验并应用所选选项的`costs`，同时将这些消耗记录到`summary_of_sacrifice`中。
3.  **战斗拦截**：如果选项包含`battle`类型的消耗，则触发战斗流程，将状态`status`置为`IN_BATTLE`，并创建战斗会话。
4.  **推进轮次**：若未触发战斗且未达到最大轮次，则递增`currentRound`，再次调用`callAI`生成下一轮内容，并更新状态。

当所有轮次完成或战斗结束后，系统会调用`settleDungeon`进行结算。

**Section sources**
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L34-L134)
- [types.ts](file://lib/dungeon/types.ts#L181-L200)

## 五轮制副本相位与AI叙事逻辑

副本系统采用五轮制设计，每一轮对应一个独特的叙事相位，由`getPhase`方法定义。`callAI`方法通过`getSystemPrompt`生成一个强大的System Prompt，引导AI严格按照这些相位逻辑生成内容。

### System Prompt的引导作用

`getSystemPrompt`是整个AI叙事的“天道法则”。它向AI明确传达了以下核心指令：

1.  **核心叙事相位逻辑**：Prompt强制AI根据`currentRound`切换叙事重点：
    *   **【Phase 1: 潜入期】(Round 1)**：侧重环境描写，如发现阵法、禁制或古修遗迹入口，选项偏向探测与尝试。
    *   **【Phase 2: 变局期】(Round 2-3)**：引入转折，如遭遇残存傀儡、禁制反弹或发现同道斗法留下的血迹，开始消耗资源。
    *   **【Phase 3: 夺宝/死战期】(Round 4)**：副本高潮，面对核心守护者或最强禁制，选项必须包含极高风险或巨量消耗。
    *   **【Phase 4: 结尾期】(Round 5)**：禁制崩塌或取宝后的逃亡，评估玩家之前的行为，决定最终的狼狈程度或圆满程度。

2.  **凡人流叙事准则**：要求AI采用简练、冰冷、充满古意的文风，并根据玩家性格（谨慎/狂傲）调整选项描述，同时遵循“因果律”，将玩家的历史行为（如法宝损坏）体现在后续叙事中。

3.  **强制选项模板**：规定AI必须生成三个选项，分别对应：
    *   **选项 A (求稳)**：低风险、低收益，体现“韩立式谨慎”。
    *   **选项 B (弄险)**：高风险、高收益，体现“富贵险中求”。
    *   **选项 C (奇招)**：触发玩家的特定属性、道具、功法或命格。

4.  **输出约束**：要求AI以JSON格式输出，并严格使用预定义的`COST_TYPES`（如灵石损耗、气血损耗、遭遇战斗等）来描述消耗。

此设计确保了AI生成的内容不仅具有丰富的叙事性，而且在结构和逻辑上完全符合游戏规则，为后端处理提供了可靠的数据基础。

### 境界差距与动态难度调整

为增强游戏的公平性和沉浸感，系统引入了境界差距计算功能。`getSystemPrompt`方法在生成Prompt前，会执行以下步骤：

1.  **计算境界差距**：通过`calculateRealmGap`方法，比较玩家境界（`playerInfo.realm`）与地图要求境界（`mapNode.realm_requirement`），返回一个数值（正数表示玩家更强，负数表示地图更难）。
2.  **生成叙事指导**：根据计算出的`realmGap`，`getRealmGuidance`方法会生成一段叙事指导文本，作为System Prompt的前置内容，直接影响AI的生成逻辑。

**境界差距的影响**：
*   **差距≥2个大境界（碾压）**：叙事指导会要求AI避免使用“险象环生”、“死里逃生”等词汇，风险选项的危险程度大幅降低，代价（costs）应极少或轻微，战斗难度系数（battle.value）不应超过3，整体危险分（danger_score）应保持在30以下。此时，`getPhase`方法会返回“探索期”、“收获期”、“收尾期”、“圆满期”等简化相位。
*   **差距=1个大境界（优势）**：体现“有一定优势但不至于碾压”的状态，风险和代价适中偏低。
*   **差距=0（相当）**：体现“正常挑战难度”，风险和代价中等。
*   **差距<0（挑战）**：体现“高风险高挑战”，但仍有机会通过谨慎操作成功。

此机制确保了副本的叙事难度和风险提示能根据玩家的实际实力动态调整，提升了游戏体验。

**Section sources**
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L36-L96)
- [types.ts](file://lib/dungeon/types.ts#L6-L28)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L44-L86)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L116-L191)

## 危险分与资源消耗机制

### 危险分 (dangerScore) 动态计算

`dangerScore`是一个0-100的数值，用于量化副本的危险程度。它的变化完全由AI在每轮生成的`internal_danger_score`决定。`getSystemPrompt`中明确规定：
*   选择危险路径时，分值应上升。
*   选择稳健路径时，分值应微降或不变。

其数值含义如下：
*   **0-30**：相对安全，收获一般。
*   **31-70**：很有挑战，收获尚可。
*   **71-100**：必死之局或绝境，但往往有丰厚的收获。

这个分数是最终结算等级的重要依据之一。

### 资源消耗与`summary_of_sacrifice`

`summary_of_sacrifice`是记录玩家在整个副本中所有资源消耗的数组。每当玩家选择一个带有`costs`的选项时，这些消耗（如灵石、气血、法宝损坏、遭遇战斗等）都会被推入此数组。

在最终结算时，`settleDungeon`方法会将`summary_of_sacrifice`作为核心输入传递给AI。结算的System Prompt中明确指出“等价交换”的核心准则：
*   **惨烈补偿**：若玩家损失了法宝、消耗了大量寿元或多次陷入死斗，结算等级严禁低于B。
*   **风险对冲**：危险分越高，最终获得的奖励品阶必须越高。
*   **凡人逻辑**：付出巨大却毫无所获的结局是被禁止的。

AI会根据这些消耗和危险分，生成一个“让玩家感到物有所值”的结局叙事和奖励等级（S/A/B/C/D）。后端再根据此等级从真实的奖励池中发放奖励，确保游戏经济的平衡。

### 资源引擎与事务性处理

为了提升资源管理的健壮性和一致性，系统将资源消耗与获得的逻辑从`DungeonService`中剥离，交由新的`ResourceEngine`服务处理。

1.  **资源消耗 (`consume`)**：
    *   在`handleAction`方法中，当玩家选择带有消耗的选项时，系统会调用`resourceEngine.consume`。
    *   `ResourceEngine`首先通过`validate`方法校验玩家是否拥有足够的资源（如灵石、寿元、材料）。
    *   校验通过后，在数据库事务中执行实际的资源扣除操作，确保操作的原子性。如果扣除过程中发生任何错误，事务会回滚，保证数据一致性。
    *   成功后，`DungeonService`再将消耗记录到`summary_of_sacrifice`中。

2.  **资源获得 (`gain`)**：
    *   在`settleDungeon`方法中，当AI生成结算结果后，系统会调用`resourceEngine.gain`来发放奖励。
    *   `ResourceEngine`同样在事务中执行资源增加操作，支持灵石、修为、材料、法宝、消耗品等多种资源类型。
    *   这种设计将资源处理逻辑集中化，避免了在多个业务模块中重复实现，提高了代码的可维护性。

**Section sources**
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L117-L121)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L329-L346)
- [ResourceEngine.ts](file://engine/resource/ResourceEngine.ts#L135-L244)
- [ResourceEngine.ts](file://engine/resource/ResourceEngine.ts#L249-L340)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L284-L293)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L648-L653)

## 战斗拦截与集成机制

当玩家选择的选项包含`battle`类型的消耗时，系统会通过“战斗拦截”机制，无缝集成到主战斗系统。

### 战斗会话创建 (`createBattleSession`)

`createBattleSession`方法负责创建一个战斗会话：
1.  **计算战前状态**：根据`summary_of_sacrifice`中的`hp_loss`和`mp_loss`，计算玩家在进入战斗时的实际气血和灵力。
2.  **生成敌人**：调用`enemyGenerator`，根据`battleCost`中的难度系数和元数据（敌人名称、境界等）生成一个符合要求的敌人。
3.  **创建会话对象**：构建一个`BattleSession`对象，包含唯一的`battleId`、指向副本状态的`dungeonStateKey`、玩家快照（当前气血/灵力）和敌人数据。
4.  **持久化会话**：将`BattleSession`和生成的敌人对象一起存入Redis，键名为`dungeon:battle:${battleId}`。

### 战斗回调与状态恢复 (`handleBattleCallback`)

战斗结束后，前端会调用`/api/dungeon/battle/execute`路由。该路由在执行完战斗模拟后，会并发地：
1.  **流式返回战斗报告**：通过SSE向客户端发送战斗过程的文本描述。
2.  **调用`handleBattleCallback`**：通知`DungeonService`战斗结果。

`handleBattleCallback`方法会：
1.  **恢复副本状态**：从Redis中获取`DungeonState`。
2.  **更新叙事**：根据战斗结果（胜利/失败）生成一段叙事文本，并更新到上一轮的历史记录中。
3.  **推进状态**：将`status`重置为`EXPLORING`，递增`currentRound`。
4.  **继续副本流程**：如果未结束，则再次调用`callAI`生成下一轮内容；如果已结束，则进行最终结算。

```mermaid
sequenceDiagram
participant 前端 as 前端
participant API as /api/dungeon/action
participant 服务 as DungeonService
participant Redis as Redis
participant 战斗API as /api/dungeon/battle/execute
participant 战斗引擎 as battleEngine
前端->>API : POST 选择战斗选项
API->>服务 : handleAction(choice)
服务->>服务 : resourceEngine.consume (校验并扣除资源)
服务->>服务 : createBattleSession()
服务->>Redis : 存储 BattleSession (dungeon : battle : {id})
服务->>API : 返回 TRIGGER_BATTLE 和 battleId
API->>前端 : 响应 battleId
前端->>战斗API : POST /execute {battleId}
战斗API->>Redis : 获取 BattleSession 和敌人
战斗API->>战斗引擎 : simulateBattle(player, enemy, hp/mp)
战斗引擎-->>战斗API : 返回战斗结果
战斗API->>服务 : handleBattleCallback(result)
服务->>服务 : 更新历史记录 (outcome)
服务->>服务 : callAI() 生成下一轮
服务->>服务 : saveState()
服务-->>战斗API : 返回下一轮数据或结算结果
战斗API->>前端 : SSE 流式发送战斗报告和最终结果
```

**Diagram sources **
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L210-L276)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L278-L324)
- [battle/execute/route.ts](file://app/api/dungeon/battle/execute/route.ts#L1-L181)

**Section sources**
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L154-L177)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L278-L324)

## 状态流转与交互序列

```mermaid
stateDiagram-v2
[*] --> Idle
Idle --> EXPLORING : startDungeon()
EXPLORING --> IN_BATTLE : handleAction() with battle cost
IN_BATTLE --> EXPLORING : handleBattleCallback()
EXPLORING --> EXPLORING : handleAction() without battle
EXPLORING --> FINISHED : currentRound >= maxRounds
IN_BATTLE --> FINISHED : handleBattleCallback() on final round
FINISHED --> [*] : Settlement Displayed
state EXPLORING {
[*] --> WaitingForChoice
WaitingForChoice --> ProcessingChoice : Player selects option
ProcessingChoice --> EXPLORING : Update state & callAI()
ProcessingChoice --> IN_BATTLE : Trigger battle
}
state IN_BATTLE {
[*] --> ExecutingBattle
ExecutingBattle --> EXPLORING : Battle success
ExecutingBattle --> FINISHED : Battle on final round
}
```

**Diagram sources **
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L180-L190)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L288-L290)

## 异常情况恢复策略

系统设计了多种策略来应对异常情况，确保玩家体验的连贯性。

### 灵石不足等硬性校验

在`handleAction`的`resourceEngine.consume`阶段，系统会对消耗进行硬性校验。例如，如果选项要求消耗1000灵石而玩家不足，则会直接抛出错误，阻止该操作。这保证了游戏经济的严谨性。

### 连接中断与状态恢复

由于副本状态完全存储在Redis中，因此连接中断不会导致进度丢失。玩家在重新连接后，前端会调用`/api/dungeon/state`路由。该路由通过`DungeonService.getState()`从Redis中读取当前状态，并恢复整个副本的UI，包括历史记录和当前选项，使玩家可以无缝继续游戏。

### 放弃副本

玩家可以随时通过`quitDungeon`方法放弃当前副本。该方法会将当前状态（标记为“放弃”）存档到数据库，并从Redis中清除，释放资源。

**Section sources**
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L147-L151)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L517-L541)
- [state/route.ts](file://app/api/dungeon/state/route.ts#L1-L39)

## 副本限制器

为控制玩家参与副本的频率，系统引入了副本限制器功能，通过`lib/dungeon/dungeonLimiter.ts`实现。

### 限制逻辑

副本限制器基于Redis实现，其核心逻辑如下：
1.  **限制规则**：每个玩家每日最多可参与2次副本。
2.  **Redis键设计**：使用`dungeon:daily:{cultivatorId}:{YYYY-MM-DD}`作为键名，确保计数按天隔离。
3.  **过期时间**：为键设置24小时（86400秒）的过期时间，确保次日自动重置，无需手动清理。

### 核心方法

`dungeonLimiter.ts`提供了两个核心方法：
*   **`checkDungeonLimit`**：检查玩家当日剩余次数。通过`redis.get`获取当前计数，计算已用次数和剩余次数，返回`{ allowed, remaining, used }`对象。
*   **`consumeDungeonLimit`**：消耗一次副本次数。通过`redis.incr`原子性地增加计数，并通过`redis.expire`确保键的过期时间。

### 与主流程集成

在`DungeonService.startDungeon`方法中，系统在初始化副本前会调用`checkDungeonLimit`进行检查。如果次数已用尽，则抛出错误阻止进入。一旦检查通过，立即调用`consumeDungeonLimit`消耗次数，确保资源的原子性。

前端通过`useDungeonLimit` Hook和`/api/dungeon/limit`路由获取当前限制信息，为玩家提供清晰的UI提示。

**Section sources**
- [dungeonLimiter.ts](file://lib/dungeon/dungeonLimiter.ts#L1-L56)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L203-L218)
- [route.ts](file://app/api/dungeon/limit/route.ts#L1-L24)
- [useDungeonLimit.ts](file://lib/hooks/dungeon/useDungeonLimit.ts#L1-L69)

## 副本历史

系统新增了副本历史功能，允许玩家回顾过往的探险记录。

### 数据存储

副本历史数据存储在数据库的`wanjiedaoyou_dungeon_histories`表中，由`lib/drizzle/schema.ts`定义。关键字段包括：
*   `cultivatorId`：关联玩家。
*   `theme`：副本主题。
*   `result`：AI生成的结算结果，包含结局叙事和奖励等级。
*   `log`：完整的交互日志，格式为`[Round X] 场景 -> Choice: 选择`。
*   `realGains`：后端实际发放的奖励列表。

### 后端实现

*   **存档**：在`DungeonService.archiveDungeon`方法中，当副本结算或玩家放弃时，系统会将`DungeonState`中的`theme`、`result`、`log`和`realGains`等信息插入`dungeonHistories`表。
*   **查询**：`app/api/dungeon/history/route.ts`提供了分页查询接口。它首先统计总数，然后按创建时间倒序查询指定页码的记录，返回包含分页信息的响应。

### 前端实现

`app/(main)/game/dungeon/history/page.tsx`是历史记录的前端页面。其主要功能包括：
1.  **数据获取**：使用`fetch`调用`/api/dungeon/history`接口，支持分页参数。
2.  **日志解析**：通过`parseDungeonLog`函数将原始日志字符串解析为结构化的`LogEntry`数组。
3.  **UI展示**：以卡片列表形式展示记录，支持展开查看详细日志、结局叙事和获得的物品。提供分页控件。

**Section sources**
- [schema.ts](file://lib/drizzle/schema.ts#L281-L291)
- [service_v2.ts](file://lib/dungeon/service_v2.ts#L824-L869)
- [route.ts](file://app/api/dungeon/history/route.ts#L1-L65)
- [page.tsx](file://app/(main)/game/dungeon/history/page.tsx#L1-L286)

## 结论

《万界道友》的副本系统通过一个精巧的状态机设计，成功地将AIGC的强大叙事能力与传统游戏的确定性规则相结合。其核心亮点在于：
1.  **结构化AI引导**：通过精心设计的System Prompt，将AI的“天马行空”约束在“凡人流”的叙事框架内。
2.  **动态状态管理**：利用Redis实现状态的持久化和恢复，支持复杂的多步骤流程。
3.  **模块化集成**：通过“战斗拦截”机制，将AI驱动的剧情与独立的战斗引擎无缝集成。
4.  **公平的奖励机制**：`summary_of_sacrifice`和“等价交换”原则确保了玩家的付出能得到符合预期的回报。
5.  **动态难度调整**：新增的境界差距计算功能，使副本叙事能根据玩家实力动态调整，提升了游戏的公平性和沉浸感。
6.  **事务性资源管理**：通过`ResourceEngine`实现了资源操作的事务性处理，保证了数据的一致性和系统的健壮性。
7.  **新增功能**：副本限制器和副本历史功能的加入，完善了系统的长期可玩性和玩家体验，分别通过Redis和数据库实现了频率控制和数据追溯。

这一设计为构建深度、动态且可玩性高的AI驱动游戏提供了一个优秀的范例。